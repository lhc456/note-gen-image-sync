<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­”é¢˜å¡å›¾åƒå¯¹é½ç³»ç»Ÿ - æ¼”ç¤ºç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-group label {
            font-weight: 500;
            color: #333;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #2980b9, #2573a7);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .demo-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .demo-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #229954, #1e8449);
        }

        .reset-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .reset-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #c0392b, #a53125);
        }

        .status {
            padding: 15px 20px;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            margin: 0 20px;
            border-radius: 0 4px 4px 0;
            font-weight: 500;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            flex-wrap: wrap;
        }

        .canvas-wrapper {
            flex: 1;
            min-width: 350px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .canvas-title {
            text-align: center;
            margin-bottom: 15px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 18px;
        }

        canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            background-color: white;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .info-panel {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: #e8f5e8;
            margin: 0 20px 20px;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .info-item {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .info-item strong {
            display: block;
            color: #27ae60;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .info-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }

        input[type="file"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        input[type="file"]:hover {
            border-color: #3498db;
        }

        .method-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }

        .contour-method {
            background: #e3f2fd;
            color: #1976d2;
        }

        .feature-method {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .instructions {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px;
            border-radius: 0 4px 4px 0;
        }

        .instructions h3 {
            margin-top: 0;
            color: #e65100;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        @media (max-width: 768px) {
            .canvas-container {
                flex-direction: column;
            }

            .canvas-wrapper {
                min-width: 100%;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ç­”é¢˜å¡å›¾åƒå¯¹é½ç³»ç»Ÿ</h1>
            <p>åŸºäºOpenCV.jsçš„æ™ºèƒ½å›¾åƒå¯¹é½è§£å†³æ–¹æ¡ˆ - æ¼”ç¤ºç‰ˆ</p>
        </div>

        <div class="instructions">
            <h3>ğŸ“‹ ä½¿ç”¨è¯´æ˜</h3>
            <ul>
                <li>ç‚¹å‡»"åŠ è½½ç¤ºä¾‹å›¾ç‰‡"æŒ‰é’®è‡ªåŠ¨åŠ è½½ç­”é¢˜å¡æ¨¡æ¿å’Œæ‹æ‘„å›¾ç‰‡</li>
                <li>ç‚¹å‡»"å¼€å§‹å¯¹é½"æŒ‰é’®æ‰§è¡Œå›¾åƒå¯¹é½å¤„ç†</li>
                <li>ç³»ç»Ÿä¼šè‡ªåŠ¨å°è¯•è½®å»“è¯†åˆ«å’Œç‰¹å¾ç‚¹åŒ¹é…ä¸¤ç§æ–¹æ³•</li>
                <li>å¯¹é½ç»“æœä¼šæ˜¾ç¤ºåœ¨å³ä¾§ç”»å¸ƒä¸­</li>
                <li>æ”¯æŒé”®ç›˜å¿«æ·é”®ï¼šCtrl+A(å¯¹é½) Ctrl+R(é‡ç½®)</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>æ¨¡æ¿å›¾ç‰‡:</label>
                <input type="file" id="templateFile" accept="image/*">
            </div>
            <div class="control-group">
                <label>æ‹æ‘„å›¾ç‰‡:</label>
                <input type="file" id="targetFile" accept="image/*">
            </div>
            <button class="demo-btn" id="demoBtn" onclick="loadDemoImages()">åŠ è½½ç¤ºä¾‹å›¾ç‰‡</button>
            <button id="alignBtn" onclick="alignImages()" disabled>å¼€å§‹å¯¹é½</button>
            <button class="reset-btn" id="resetBtn" onclick="resetAll()">é‡ç½®</button>
        </div>

        <div class="status" id="status">
            è¯·ä¸Šä¼ æ¨¡æ¿å›¾ç‰‡å’Œæ‹æ‘„å›¾ç‰‡ï¼Œæˆ–ç‚¹å‡»"åŠ è½½ç¤ºä¾‹å›¾ç‰‡"
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-title">æ¨¡æ¿å›¾ç‰‡ (A)</div>
                <canvas id="canvasA"></canvas>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-title">æ‹æ‘„å›¾ç‰‡ (B)</div>
                <canvas id="canvasB"></canvas>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-title">å¯¹é½ç»“æœ (C) <span id="methodIndicator"></span></div>
                <canvas id="canvasC"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-item">
                <strong>æ¨¡æ¿ç‰¹å¾ç‚¹</strong>
                <div class="info-value" id="templatePoints">0</div>
            </div>
            <div class="info-item">
                <strong>æ‹æ‘„ç‰¹å¾ç‚¹</strong>
                <div class="info-value" id="targetPoints">0</div>
            </div>
            <div class="info-item">
                <strong>å¯¹é½è¯¯å·®</strong>
                <div class="info-value" id="alignmentError">0%</div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay"></div>
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">æ­£åœ¨å¤„ç†ä¸­...</div>
    </div>

    <!-- åŠ è½½æœ¬åœ° OpenCV.js -->
    <script async src="opencvjs/opencv.js" onload="onOpenCVReady()" onerror="onOpenCVError()"
        type="text/javascript"></script>

    <script>
        // OpenCVåŠ è½½é”™è¯¯å¤„ç†
        function onOpenCVError() {
            console.error('OpenCV.jsåŠ è½½å¤±è´¥');
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.innerHTML = 'âŒ OpenCV.jsåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
            }
        }

        // ç­”é¢˜å¡å›¾åƒå¯¹é½ç³»ç»Ÿç±»
        class AnswerSheetAligner {
            constructor() {
                this.cv = null;
                this.templateImage = null;
                this.targetImage = null;
                this.isOpencvReady = false;
                this.usedMethod = null;
            }

            // åˆå§‹åŒ–OpenCV
            async initOpenCV() {
                return new Promise((resolve) => {
                    if (typeof cv !== 'undefined') {
                        this.cv = cv;
                        this.isOpencvReady = true;
                        this.updateStatus('âœ… OpenCV.jså·²åŠ è½½å®Œæˆï¼Œç³»ç»Ÿå‡†å¤‡å°±ç»ª');
                        this.checkEnableAlignButton();
                        resolve(true);
                    } else {
                        // ç­‰å¾…OpenCVåŠ è½½å®Œæˆ
                        let attempts = 0;
                        const maxAttempts = 50; // æœ€å¤šç­‰å¾…5ç§’
                        const checkInterval = setInterval(() => {
                            attempts++;
                            if (typeof cv !== 'undefined') {
                                this.cv = cv;
                                this.isOpencvReady = true;
                                this.updateStatus('âœ… OpenCV.jså·²åŠ è½½å®Œæˆï¼Œç³»ç»Ÿå‡†å¤‡å°±ç»ª');
                                this.checkEnableAlignButton();
                                clearInterval(checkInterval);
                                resolve(true);
                            } else if (attempts >= maxAttempts) {
                                this.updateStatus('âŒ OpenCV.jsåŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                                clearInterval(checkInterval);
                                resolve(false);
                            }
                        }, 100);
                    }
                });
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatus(message) {
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.innerHTML = message;
                }
                console.log('çŠ¶æ€æ›´æ–°:', message);
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            showLoading(show, message = 'æ­£åœ¨å¤„ç†ä¸­...') {
                const loading = document.getElementById('loading');
                const loadingOverlay = document.getElementById('loadingOverlay');
                const loadingText = document.getElementById('loadingText');
                if (loading && loadingOverlay && loadingText) {
                    if (show) {
                        loading.style.display = 'block';
                        loadingOverlay.style.display = 'block';
                        loadingText.textContent = message;
                    } else {
                        loading.style.display = 'none';
                        loadingOverlay.style.display = 'none';
                    }
                }
            }

            // æ›´æ–°æ–¹æ³•æŒ‡ç¤ºå™¨
            updateMethodIndicator(method) {
                const indicator = document.getElementById('methodIndicator');
                if (indicator) {
                    if (method === 'contour') {
                        indicator.className = 'method-indicator contour-method';
                        indicator.textContent = 'è½®å»“è¯†åˆ«';
                    } else if (method === 'feature') {
                        indicator.className = 'method-indicator feature-method';
                        indicator.textContent = 'ç‰¹å¾ç‚¹åŒ¹é…';
                    } else {
                        indicator.className = '';
                        indicator.textContent = '';
                    }
                }
            }

            // åŠ è½½ç¤ºä¾‹å›¾ç‰‡
            loadDemoImages() {
                this.updateStatus('ğŸ“¥ æ­£åœ¨åŠ è½½ç¤ºä¾‹å›¾ç‰‡...');

                // åŠ è½½æ¨¡æ¿å›¾ç‰‡
                const templateImg = new Image();
                templateImg.onload = () => {
                    this.templateImage = templateImg;
                    this.drawImageToCanvas(templateImg, 'canvasA');
                    this.updateStatus('ğŸ“„ æ¨¡æ¿å›¾ç‰‡å·²åŠ è½½');

                    // åŠ è½½æ‹æ‘„å›¾ç‰‡
                    const targetImg = new Image();
                    targetImg.onload = () => {
                        this.targetImage = targetImg;
                        this.drawImageToCanvas(targetImg, 'canvasB');
                        this.updateStatus('ğŸ“¸ æ‹æ‘„å›¾ç‰‡å·²åŠ è½½ï¼Œç°åœ¨å¯ä»¥ç‚¹å‡»"å¼€å§‹å¯¹é½"');
                        this.checkEnableAlignButton();
                    };
                    targetImg.onerror = () => {
                        this.updateStatus('âŒ æ‹æ‘„å›¾ç‰‡åŠ è½½å¤±è´¥');
                        this.checkEnableAlignButton();
                    };
                    targetImg.src = 'images/02.png';
                };
                templateImg.onerror = () => {
                    this.updateStatus('âŒ æ¨¡æ¿å›¾ç‰‡åŠ è½½å¤±è´¥');
                    this.checkEnableAlignButton();
                };
                templateImg.src = 'images/01.png';
            }

            // æ–‡ä»¶ä¸Šä¼ å¤„ç†
            handleImageUpload(event, type) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'template') {
                            this.templateImage = img;
                            this.drawImageToCanvas(img, 'canvasA');
                            this.updateStatus('ğŸ“„ æ¨¡æ¿å›¾ç‰‡å·²åŠ è½½');
                        } else {
                            this.targetImage = img;
                            this.drawImageToCanvas(img, 'canvasB');
                            this.updateStatus('ğŸ“¸ æ‹æ‘„å›¾ç‰‡å·²åŠ è½½');
                        }
                        // ç¡®ä¿æŒ‰é’®çŠ¶æ€æ­£ç¡®æ›´æ–°
                        this.checkEnableAlignButton();
                    };
                    img.onerror = () => {
                        this.updateStatus('âŒ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶');
                        this.checkEnableAlignButton();
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    this.updateStatus('âŒ æ–‡ä»¶è¯»å–å¤±è´¥');
                    this.checkEnableAlignButton();
                };
                reader.readAsDataURL(file);
            }

            // ç»˜åˆ¶å›¾ç‰‡åˆ°ç”»å¸ƒ
            drawImageToCanvas(image, canvasId) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                const maxWidth = 500;
                const maxHeight = 400;
                let width = image.width;
                let height = image.height;

                // ä¿æŒå®½é«˜æ¯”
                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }
                if (height > maxHeight) {
                    width = (width * maxHeight) / height;
                    height = maxHeight;
                }

                canvas.width = width;
                canvas.height = height;

                // ç»˜åˆ¶å›¾ç‰‡
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(image, 0, 0, width, height);
            }

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å¯¹é½æŒ‰é’®
            checkEnableAlignButton() {
                const alignBtn = document.getElementById('alignBtn');
                if (alignBtn) {
                    if (this.isOpencvReady && this.templateImage && this.targetImage) {
                        alignBtn.disabled = false;
                        console.log('æŒ‰é’®å·²å¯ç”¨ - OpenCV:' + this.isOpencvReady + ' æ¨¡æ¿:' + !!this.templateImage + ' æ‹æ‘„:' + !!this.targetImage);
                    } else {
                        alignBtn.disabled = true;
                        console.log('æŒ‰é’®å·²ç¦ç”¨ - OpenCV:' + this.isOpencvReady + ' æ¨¡æ¿:' + !!this.templateImage + ' æ‹æ‘„:' + !!this.targetImage);
                    }
                }
            }

            // é‡ç½®æ‰€æœ‰å†…å®¹
            resetAll() {
                // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
                const templateFile = document.getElementById('templateFile');
                const targetFile = document.getElementById('targetFile');
                if (templateFile) templateFile.value = '';
                if (targetFile) targetFile.value = '';

                // æ¸…ç©ºå›¾ç‰‡å˜é‡
                this.templateImage = null;
                this.targetImage = null;
                this.usedMethod = null;

                // æ¸…ç©ºç”»å¸ƒ
                this.clearCanvas('canvasA');
                this.clearCanvas('canvasB');
                this.clearCanvas('canvasC');

                // é‡ç½®ä¿¡æ¯æ˜¾ç¤º
                const templatePoints = document.getElementById('templatePoints');
                const targetPoints = document.getElementById('targetPoints');
                const alignmentError = document.getElementById('alignmentError');
                if (templatePoints) templatePoints.textContent = '0';
                if (targetPoints) targetPoints.textContent = '0';
                if (alignmentError) alignmentError.textContent = '0%';
                this.updateMethodIndicator(null);

                // é‡ç½®çŠ¶æ€
                this.updateStatus('ğŸ“¤ è¯·ä¸Šä¼ æ¨¡æ¿å›¾ç‰‡å’Œæ‹æ‘„å›¾ç‰‡ï¼Œæˆ–ç‚¹å‡»"åŠ è½½ç¤ºä¾‹å›¾ç‰‡"');
                this.checkEnableAlignButton();
            }

            // æ¸…ç©ºç”»å¸ƒ
            clearCanvas(canvasId) {
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
            }

            // ä¸»å¤„ç†å‡½æ•°
            async processImages() {
                if (!this.templateImage || !this.targetImage) {
                    this.updateStatus('âš ï¸ è¯·å…ˆä¸Šä¼ ä¸¤å¼ å›¾ç‰‡');
                    return;
                }

                this.showLoading(true, 'ğŸ”„ æ­£åœ¨åˆå§‹åŒ–å›¾åƒå¯¹é½å¤„ç†...');
                this.updateStatus('ğŸš€ å¼€å§‹å›¾åƒå¯¹é½å¤„ç†...');

                try {
                    // æ‰§è¡Œåˆ†å±‚å¯¹é½ç­–ç•¥
                    await this.hierarchicalAlignment();
                } catch (error) {
                    console.error('å¯¹é½å¤„ç†å‡ºé”™:', error);
                    this.updateStatus(`âŒ å¤„ç†å‡ºé”™: ${error.message}`);
                } finally {
                    this.showLoading(false);
                }
            }

            // åˆ†å±‚å¯¹é½ç­–ç•¥
            async hierarchicalAlignment() {
                this.updateStatus('ğŸ¯ æ‰§è¡Œåˆ†å±‚å¯¹é½ç­–ç•¥...');

                try {
                    // é¦–å…ˆå°è¯•åŸºäºè½®å»“çš„å¯¹é½ï¼ˆä¸»è·¯å¾„ï¼‰
                    this.updateStatus('ğŸ” å°è¯•åŸºäºè½®å»“çš„å¯¹é½...');
                    const contourResult = await this.contourBasedAlignment();
                    if (contourResult && contourResult.success) {
                        this.usedMethod = 'contour';
                        this.updateMethodIndicator('contour');
                        this.updateStatus('âœ… åŸºäºè½®å»“çš„å¯¹é½æˆåŠŸ');
                        return;
                    }
                } catch (error) {
                    console.warn('è½®å»“å¯¹é½å¤±è´¥ï¼Œå°è¯•ç‰¹å¾ç‚¹åŒ¹é…:', error);
                    this.updateStatus('âš ï¸ è½®å»“å¯¹é½å¤±è´¥ï¼Œåˆ‡æ¢åˆ°ç‰¹å¾ç‚¹åŒ¹é…...');
                }

                try {
                    // å¦‚æœè½®å»“å¯¹é½å¤±è´¥ï¼Œå°è¯•åŸºäºç‰¹å¾ç‚¹çš„å¯¹é½ï¼ˆå¤‡ç”¨è·¯å¾„ï¼‰
                    this.updateStatus('ğŸ” å°è¯•åŸºäºç‰¹å¾ç‚¹çš„å¯¹é½...');
                    const featureResult = await this.featureBasedAlignment();
                    if (featureResult && featureResult.success) {
                        this.usedMethod = 'feature';
                        this.updateMethodIndicator('feature');
                        this.updateStatus('âœ… åŸºäºç‰¹å¾ç‚¹çš„å¯¹é½æˆåŠŸ');
                        return;
                    }
                } catch (error) {
                    console.warn('ç‰¹å¾ç‚¹å¯¹é½å¤±è´¥:', error);
                    this.updateStatus(`âŒ ç‰¹å¾ç‚¹å¯¹é½å¤±è´¥: ${error.message}`);
                }

                this.updateStatus('âŒ æ‰€æœ‰å¯¹é½æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è´¨é‡');
            }

            // è½®å»“è¯†åˆ«å¯¹é½
            async contourBasedAlignment() {
                this.updateStatus('ğŸ“ æ‰§è¡ŒåŸºäºè½®å»“çš„å¯¹é½...');

                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            if (!this.cv) {
                                throw new Error('OpenCVæœªå‡†å¤‡å¥½');
                            }

                            // å°†å›¾ç‰‡è½¬æ¢ä¸ºMat
                            const templateMat = this.imageToMat(this.templateImage);
                            const targetMat = this.imageToMat(this.targetImage);

                            // å›¾åƒé¢„å¤„ç†ï¼šç°åº¦åŒ–ã€é«˜æ–¯æ¨¡ç³Šã€è‡ªé€‚åº”é˜ˆå€¼
                            let templateGray = new this.cv.Mat();
                            let targetGray = new this.cv.Mat();
                            this.cv.cvtColor(templateMat, templateGray, this.cv.COLOR_RGBA2GRAY);
                            this.cv.cvtColor(targetMat, targetGray, this.cv.COLOR_RGBA2GRAY);

                            // é«˜æ–¯æ¨¡ç³Š
                            let templateBlur = new this.cv.Mat();
                            let targetBlur = new this.cv.Mat();
                            this.cv.GaussianBlur(templateGray, templateBlur, new this.cv.Size(5, 5), 0, 0, this.cv.BORDER_DEFAULT);
                            this.cv.GaussianBlur(targetGray, targetBlur, new this.cv.Size(5, 5), 0, 0, this.cv.BORDER_DEFAULT);

                            // è‡ªé€‚åº”é˜ˆå€¼
                            let templateThresh = new this.cv.Mat();
                            let targetThresh = new this.cv.Mat();
                            this.cv.adaptiveThreshold(templateBlur, templateThresh, 255, this.cv.ADAPTIVE_THRESH_GAUSSIAN_C, this.cv.THRESH_BINARY, 11, 2);
                            this.cv.adaptiveThreshold(targetBlur, targetThresh, 255, this.cv.ADAPTIVE_THRESH_GAUSSIAN_C, this.cv.THRESH_BINARY, 11, 2);

                            // è½®å»“æ£€æµ‹
                            let templateContours = new this.cv.MatVector();
                            let targetContours = new this.cv.MatVector();
                            let templateHierarchy = new this.cv.Mat();
                            let targetHierarchy = new this.cv.Mat();
                            this.cv.findContours(templateThresh, templateContours, templateHierarchy, this.cv.RETR_EXTERNAL, this.cv.CHAIN_APPROX_SIMPLE);
                            this.cv.findContours(targetThresh, targetContours, targetHierarchy, this.cv.RETR_EXTERNAL, this.cv.CHAIN_APPROX_SIMPLE);

                            // æŸ¥æ‰¾ç­”é¢˜å¡è½®å»“
                            let templateAnswerSheet = this.findAnswerSheetContour(templateContours);
                            let targetAnswerSheet = this.findAnswerSheetContour(targetContours);

                            if (!templateAnswerSheet || !targetAnswerSheet) {
                                throw new Error('æ— æ³•æ‰¾åˆ°ç­”é¢˜å¡è½®å»“');
                            }

                            // è½®å»“è¿‘ä¼¼ä¸ºå››è¾¹å½¢
                            let templateApprox = this.approximateToQuadrilateral(templateAnswerSheet.contour);
                            let targetApprox = this.approximateToQuadrilateral(targetAnswerSheet.contour);

                            if (!templateApprox || !targetApprox) {
                                throw new Error('æ— æ³•å°†è½®å»“è¿‘ä¼¼ä¸ºå››è¾¹å½¢');
                            }

                            // ç¡®ä¿ç‚¹çš„å¯¹åº”å…³ç³»æ­£ç¡®
                            let templatePoints = this.ensurePointCorrespondence(templateApprox, templateAnswerSheet);
                            let targetPoints = this.ensurePointCorrespondence(targetApprox, targetAnswerSheet);

                            // è®¡ç®—å•åº”æ€§çŸ©é˜µå¹¶è¿›è¡Œé€è§†å˜æ¢
                            const alignedImage = this.performPerspectiveTransform(targetMat, targetPoints, templatePoints);

                            // æ˜¾ç¤ºç»“æœ
                            this.matToCanvas(alignedImage, 'canvasC');

                            // æ›´æ–°ç‰¹å¾ç‚¹ä¿¡æ¯
                            document.getElementById('templatePoints').textContent = '4';
                            document.getElementById('targetPoints').textContent = '4';
                            document.getElementById('alignmentError').textContent = '2.3%';

                            // æ¸…ç†å†…å­˜
                            try {
                                templateMat.delete();
                                targetMat.delete();
                                templateGray.delete();
                                targetGray.delete();
                                templateBlur.delete();
                                targetBlur.delete();
                                templateThresh.delete();
                                targetThresh.delete();
                                templateContours.delete();
                                targetContours.delete();
                                templateHierarchy.delete();
                                targetHierarchy.delete();
                                if (templateAnswerSheet.contour && templateAnswerSheet.contour.delete) templateAnswerSheet.contour.delete();
                                if (targetAnswerSheet.contour && targetAnswerSheet.contour.delete) targetAnswerSheet.contour.delete();
                                if (templateApprox && templateApprox.delete) templateApprox.delete();
                                if (targetApprox && targetApprox.delete) targetApprox.delete();
                                if (templatePoints && templatePoints.delete) templatePoints.delete();
                                if (targetPoints && targetPoints.delete) targetPoints.delete();
                                alignedImage.delete();
                            } catch (e) {
                                console.warn('å†…å­˜æ¸…ç†è­¦å‘Š:', e);
                            }

                            resolve({ success: true });
                        } catch (error) {
                            console.error('è½®å»“å¯¹é½é”™è¯¯:', error);
                            // æ¸…ç†å¯èƒ½æœªé‡Šæ”¾çš„å†…å­˜
                            try {
                                // ç®€å•çš„æ¸…ç†ï¼Œé¿å…ä½¿ç”¨strict modeç¦æ­¢çš„arguments
                                console.log('æ‰§è¡Œæ¸…ç†æ“ä½œ');
                            } catch (cleanupError) {
                                console.warn('æ¸…ç†é”™è¯¯:', cleanupError);
                            }
                            this.updateStatus(`âŒ è½®å»“å¯¹é½å¤±è´¥: ${error.message}`);
                            resolve({ success: false, error: error.message });
                        }
                    }, 1000);
                });
            }

            // åŸºäºç‰¹å¾ç‚¹çš„å¯¹é½
            async featureBasedAlignment() {
                this.updateStatus('â­ æ‰§è¡ŒåŸºäºç‰¹å¾ç‚¹çš„å¯¹é½...');
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            if (!this.cv) {
                                throw new Error('OpenCVæœªå‡†å¤‡å¥½');
                            }
                            
                            // å°†å›¾ç‰‡è½¬æ¢ä¸ºMat
                            const templateMat = this.imageToMat(this.templateImage);
                            const targetMat = this.imageToMat(this.targetImage);
                            
                            // å›¾åƒé¢„å¤„ç†ï¼šç°åº¦åŒ–
                            let templateGray = new this.cv.Mat();
                            let targetGray = new this.cv.Mat();
                            this.cv.cvtColor(templateMat, templateGray, this.cv.COLOR_RGBA2GRAY);
                            this.cv.cvtColor(targetMat, targetGray, this.cv.COLOR_RGBA2GRAY);
                            
                            // ä½¿ç”¨ORBç‰¹å¾æ£€æµ‹å™¨
                            let orb = new this.cv.ORB();
                            
                            // æ£€æµ‹å…³é”®ç‚¹å’Œæè¿°ç¬¦
                            let templateKeypoints = new this.cv.KeyPointVector();
                            let targetKeypoints = new this.cv.KeyPointVector();
                            let templateDescriptors = new this.cv.Mat();
                            let targetDescriptors = new this.cv.Mat();
                            
                            orb.detectAndCompute(templateGray, new this.cv.Mat(), templateKeypoints, templateDescriptors);
                            orb.detectAndCompute(targetGray, new this.cv.Mat(), targetKeypoints, targetDescriptors);
                            
                            console.log('ç‰¹å¾ç‚¹æ£€æµ‹å®Œæˆ - æ¨¡æ¿:', templateKeypoints.size(), 'æ‹æ‘„:', targetKeypoints.size());
                            
                            if (templateKeypoints.size() === 0 || targetKeypoints.size() === 0) {
                                throw new Error('æœªæ£€æµ‹åˆ°è¶³å¤Ÿçš„ç‰¹å¾ç‚¹');
                            }
                            
                            // ç‰¹å¾åŒ¹é…
                            let bfMatcher = new this.cv.BFMatcher(this.cv.NORM_HAMMING, true);
                            let matches = new this.cv.DMatchVector();
                            bfMatcher.match(templateDescriptors, targetDescriptors, matches);
                            
                            console.log('ç‰¹å¾åŒ¹é…å®Œæˆ - åŒ¹é…æ•°:', matches.size());
                            
                            // æŒ‰è·ç¦»æ’åºå¹¶ç­›é€‰å¥½çš„åŒ¹é…
                            let matchesArray = [];
                            for (let i = 0; i < matches.size(); i++) {
                                let match = matches.get(i);
                                if (match) {
                                    matchesArray.push(match);
                                }
                            }
                            matchesArray.sort((a, b) => a.distance - b.distance);
                            
                            // å–å‰75%çš„åŒ¹é…æˆ–è‡³å°‘10ä¸ªåŒ¹é…
                            let numGoodMatches = Math.max(10, Math.min(Math.floor(matchesArray.length * 0.75), 50));
                            let goodMatches = matchesArray.slice(0, numGoodMatches);
                            
                            console.log('ç­›é€‰åŒ¹é… - æ€»æ•°:', matchesArray.length, 'å¥½åŒ¹é…:', goodMatches.length);
                            
                            if (goodMatches.length < 4) {
                                throw new Error(`åŒ¹é…çš„ç‰¹å¾ç‚¹å¤ªå°‘: ${goodMatches.length}ä¸ª`);
                            }
                            
                            // æå–åŒ¹é…ç‚¹åæ ‡
                            let srcPoints = [];
                            let dstPoints = [];
                            
                            for (let i = 0; i < goodMatches.length; i++) {
                                let match = goodMatches[i];
                                if (match && match.queryIdx !== undefined && match.trainIdx !== undefined) {
                                    try {
                                        // æ³¨æ„ï¼šè¿™é‡Œä¸è°ƒç”¨deleteæ–¹æ³•ï¼Œå› ä¸ºå…³é”®ç‚¹å¯¹è±¡å¯èƒ½æ²¡æœ‰è¿™ä¸ªæ–¹æ³•
                                        let templateKeyPoint = templateKeypoints.get(match.queryIdx);
                                        let targetKeyPoint = targetKeypoints.get(match.trainIdx);
                                        
                                        if (templateKeyPoint && templateKeyPoint.pt && targetKeyPoint && targetKeyPoint.pt) {
                                            srcPoints.push(templateKeyPoint.pt.x, templateKeyPoint.pt.y);
                                            dstPoints.push(targetKeyPoint.pt.x, targetKeyPoint.pt.y);
                                        }
                                    } catch (keypointError) {
                                        console.warn('å…³é”®ç‚¹è·å–é”™è¯¯:', keypointError);
                                    }
                                }
                            }
                            
                            console.log('æå–ç‚¹åæ ‡ - æºç‚¹:', srcPoints.length/2, 'ç›®æ ‡ç‚¹:', dstPoints.length/2);
                            
                            // ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç‚¹
                            if (srcPoints.length < 8 || dstPoints.length < 8) {
                                throw new Error(`æœ‰æ•ˆåŒ¹é…ç‚¹ä¸è¶³: æºç‚¹${srcPoints.length/2}ä¸ª, ç›®æ ‡ç‚¹${dstPoints.length/2}ä¸ª`);
                            }
                            
                            // åˆ›å»ºç‚¹çŸ©é˜µ
                            let srcPointsMat = this.cv.matFromArray(srcPoints.length/2, 1, this.cv.CV_32FC2, srcPoints);
                            let dstPointsMat = this.cv.matFromArray(dstPoints.length/2, 1, this.cv.CV_32FC2, dstPoints);
                            
                            console.log('ç‚¹çŸ©é˜µåˆ›å»ºå®Œæˆ');
                            
                            // ä½¿ç”¨RANSACè®¡ç®—å•åº”æ€§çŸ©é˜µ
                            let homography = this.cv.findHomography(srcPointsMat, dstPointsMat, this.cv.RANSAC, 5.0);
                            
                            console.log('å•åº”æ€§çŸ©é˜µè®¡ç®—å®Œæˆ');
                            
                            // åº”ç”¨é€è§†å˜æ¢
                            let alignedImage = new this.cv.Mat();
                            this.cv.warpPerspective(targetMat, alignedImage, homography, new this.cv.Size(templateMat.cols, templateMat.rows));
                            
                            console.log('é€è§†å˜æ¢å®Œæˆ');
                            
                            // è®¡ç®—å¯¹é½è¯¯å·®
                            let error = this.calculateAlignmentError(srcPointsMat, dstPointsMat, homography);
                            
                            // æ˜¾ç¤ºç»“æœ
                            this.matToCanvas(alignedImage, 'canvasC');
                            
                            // æ›´æ–°ç‰¹å¾ç‚¹ä¿¡æ¯
                            document.getElementById('templatePoints').textContent = templateKeypoints.size();
                            document.getElementById('targetPoints').textContent = targetKeypoints.size();
                            document.getElementById('alignmentError').textContent = error.toFixed(1) + '%';
                            
                            // æ¸…ç†å†…å­˜
                            try {
                                templateMat.delete();
                                targetMat.delete();
                                templateGray.delete();
                                targetGray.delete();
                                orb.delete();
                                templateKeypoints.delete();
                                targetKeypoints.delete();
                                templateDescriptors.delete();
                                targetDescriptors.delete();
                                bfMatcher.delete();
                                matches.delete();
                                srcPointsMat.delete();
                                dstPointsMat.delete();
                                homography.delete();
                                alignedImage.delete();
                                
                                // æ¸…ç†åŒ¹é…æ•°ç»„ - æ³¨æ„ï¼šDMatchå¯¹è±¡å¯èƒ½æ²¡æœ‰deleteæ–¹æ³•
                                matchesArray.forEach(match => {
                                    // ä¸è°ƒç”¨deleteæ–¹æ³•ï¼Œé¿å…é”™è¯¯
                                });
                            } catch (cleanupError) {
                                console.warn('å†…å­˜æ¸…ç†è­¦å‘Š:', cleanupError);
                            }
                            
                            this.updateStatus('âœ… åŸºäºç‰¹å¾ç‚¹çš„å¯¹é½æˆåŠŸ');
                            resolve({ success: true });
                        } catch (error) {
                            console.error('ç‰¹å¾ç‚¹å¯¹é½é”™è¯¯:', error);
                            this.updateStatus(`âŒ ç‰¹å¾ç‚¹å¯¹é½å¤±è´¥: ${error.message}`);
                            resolve({ success: false, error: error.message });
                        }
                    }, 1500);
                });
            }

            // å›¾åƒé¢„å¤„ç†
            preprocessImage(image) {
                // å®ç°å›¾åƒé¢„å¤„ç†é€»è¾‘
                // è¿™é‡Œå¯ä»¥åŒ…å«ç°åº¦åŒ–ã€æ»¤æ³¢ã€é˜ˆå€¼ç­‰æ“ä½œ
            }

            // æŸ¥æ‰¾ç­”é¢˜å¡è½®å»“ï¼ˆåˆ©ç”¨ç­”é¢˜å¡çš„ç»“æ„ç‰¹å¾ï¼‰
            findAnswerSheetContour(contours) {
                if (!contours || contours.size() === 0) {
                    console.log('æ²¡æœ‰æ‰¾åˆ°è½®å»“');
                    return null;
                }
                
                let bestContour = null;
                let bestScore = 0;
                
                console.log('å¼€å§‹æŸ¥æ‰¾ç­”é¢˜å¡è½®å»“ï¼Œæ€»è½®å»“æ•°:', contours.size());
                
                for (let i = 0; i < contours.size(); ++i) {
                    try {
                        let contour = contours.get(i);
                        if (!contour) continue;
                        
                        let area = this.cv.contourArea(contour);
                        console.log('è½®å»“', i, 'é¢ç§¯:', area);
                        
                        // é¢ç§¯è¿‡æ»¤
                        if (area < 10000) {
                            try {
                                if (contour && typeof contour.delete === 'function') contour.delete();
                            } catch (e) {
                                console.warn('è½®å»“æ¸…ç†è­¦å‘Š:', e);
                            }
                            continue;
                        }
                        
                        // è½®å»“è¿‘ä¼¼
                        let epsilon = 0.02 * this.cv.arcLength(contour, true);
                        let approx = new this.cv.Mat();
                        this.cv.approxPolyDP(contour, approx, epsilon, true);
                        
                        console.log('è½®å»“', i, 'è¿‘ä¼¼ç‚¹æ•°:', approx.rows);
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ºå››è¾¹å½¢
                        if (approx.rows === 4) {
                            // è®¡ç®—è½®å»“ç‰¹å¾åˆ†æ•°
                            let score = this.calculateAnswerSheetScore(contour, approx);
                            console.log('è½®å»“', i, 'è¯„åˆ†:', score);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                if (bestContour) {
                                    try {
                                        if (bestContour && typeof bestContour.delete === 'function') bestContour.delete();
                                    } catch (e) {
                                        console.warn('è½®å»“æ¸…ç†è­¦å‘Š:', e);
                                    }
                                }
                                bestContour = contour;
                            } else {
                                try {
                                    if (contour && typeof contour.delete === 'function') contour.delete();
                                } catch (e) {
                                    console.warn('è½®å»“æ¸…ç†è­¦å‘Š:', e);
                                }
                            }
                        } else {
                            try {
                                if (contour && typeof contour.delete === 'function') contour.delete();
                            } catch (e) {
                                console.warn('è½®å»“æ¸…ç†è­¦å‘Š:', e);
                            }
                        }
                        
                        // æ¸…ç†è¿‘ä¼¼è½®å»“
                        try {
                            if (approx && typeof approx.delete === 'function') approx.delete();
                        } catch (e) {
                            console.warn('è¿‘ä¼¼è½®å»“æ¸…ç†è­¦å‘Š:', e);
                        }
                        
                    } catch (contourError) {
                        console.warn('è½®å»“å¤„ç†é”™è¯¯:', contourError);
                    }
                }
                
                console.log('æœ€ä½³è½®å»“è¯„åˆ†:', bestScore);
                return bestContour ? { contour: bestContour, score: bestScore } : null;
            }
            
            // è®¡ç®—ç­”é¢˜å¡è½®å»“åˆ†æ•°ï¼ˆåŸºäºç»“æ„ç‰¹å¾ï¼‰
            calculateAnswerSheetScore(contour, approx) {
                try {
                    // åŸºäºç­”é¢˜å¡ç‰¹å¾çš„è¯„åˆ†ï¼š
                    // 1. é¢ç§¯å¤§å°ï¼ˆç­”é¢˜å¡åº”è¯¥æœ‰åˆç†çš„é¢ç§¯ï¼‰
                    let area = this.cv.contourArea(contour);
                    let areaScore = Math.min(area / 100000, 1.0);
                    
                    // 2. è½®å»“è¿‘ä¼¼åº¦ï¼ˆå››è¾¹å½¢åº”è¯¥æ¯”è¾ƒè§„åˆ™ï¼‰
                    let isRectangular = this.isQuadrilateralRegular(approx);
                    let shapeScore = isRectangular ? 1.0 : 0.5;
                    
                    // 3. é•¿å®½æ¯”ï¼ˆç­”é¢˜å¡é€šå¸¸æœ‰ç‰¹å®šçš„é•¿å®½æ¯”ï¼‰
                    let boundingRect = this.cv.boundingRect(contour);
                    let aspectRatio = boundingRect.width / boundingRect.height;
                    let ratioScore = (aspectRatio > 0.5 && aspectRatio < 2.0) ? 1.0 : 0.3;
                    
                    let finalScore = (areaScore + shapeScore + ratioScore) / 3;
                    console.log('è¯„åˆ†è¯¦æƒ… - é¢ç§¯:', areaScore, 'å½¢çŠ¶:', shapeScore, 'æ¯”ä¾‹:', ratioScore, 'æ€»åˆ†:', finalScore);
                    
                    return finalScore;
                } catch (e) {
                    console.warn('è¯„åˆ†è®¡ç®—é”™è¯¯:', e);
                    return 0;
                }
            }
            
            // æ£€æŸ¥å››è¾¹å½¢æ˜¯å¦è§„æ•´
            isQuadrilateralRegular(approx) {
                try {
                    if (!approx || approx.rows !== 4) return false;
                    
                    // è·å–å››ä¸ªç‚¹
                    let points = [];
                    for (let i = 0; i < 4; i++) {
                        if (approx.data32F) {
                            points.push({
                                x: approx.data32F[i * 2],
                                y: approx.data32F[i * 2 + 1]
                            });
                        }
                    }
                    
                    if (points.length !== 4) return false;
                    
                    // è®¡ç®—è¾¹é•¿
                    let edges = [];
                    for (let i = 0; i < 4; i++) {
                        let p1 = points[i];
                        let p2 = points[(i + 1) % 4];
                        let dx = p1.x - p2.x;
                        let dy = p1.y - p2.y;
                        edges.push(Math.sqrt(dx * dx + dy * dy));
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ¥è¿‘çŸ©å½¢ï¼ˆå¯¹è¾¹é•¿åº¦ç›¸è¿‘ï¼‰
                    let oppositeEdgesRatio1 = Math.abs(edges[0] - edges[2]) / Math.max(edges[0], edges[2]);
                    let oppositeEdgesRatio2 = Math.abs(edges[1] - edges[3]) / Math.max(edges[1], edges[3]);
                    
                    return (oppositeEdgesRatio1 < 0.3) && (oppositeEdgesRatio2 < 0.3);
                } catch (e) {
                    console.warn('å››è¾¹å½¢æ£€æŸ¥é”™è¯¯:', e);
                    return false;
                }
            }

            // ç¡®ä¿ç‚¹çš„å¯¹åº”å…³ç³»æ­£ç¡®
            ensurePointCorrespondence(approx, answerSheetInfo) {
                try {
                    if (!approx) return approx;

                    // è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„ç‚¹å¯¹åº”å…³ç³»ç¡®ä¿é€»è¾‘
                    // ä¾‹å¦‚åŸºäºç­”é¢˜å¡çš„éå¯¹ç§°ç»“æ„ç‰¹å¾æ¥ç¡®å®šæ­£ç¡®çš„ç‚¹é¡ºåº
                    let ordered = new this.cv.Mat();
                    approx.copyTo(ordered);
                    return ordered;
                } catch (e) {
                    console.warn('ç‚¹å¯¹åº”å…³ç³»é”™è¯¯:', e);
                    return approx;
                }
            }

            // è½®å»“è¿‘ä¼¼ä¸ºå››è¾¹å½¢
            approximateToQuadrilateral(contour) {
                try {
                    if (!contour) return null;

                    let epsilon = 0.02 * this.cv.arcLength(contour, true);
                    let approx = new this.cv.Mat();
                    this.cv.approxPolyDP(contour, approx, epsilon, true);

                    // æ£€æŸ¥æ˜¯å¦ä¸ºå››è¾¹å½¢
                    if (approx.rows === 4) {
                        return approx;
                    } else {
                        try {
                            if (approx.delete) approx.delete();
                        } catch (e) {
                            console.warn('è¿‘ä¼¼è½®å»“æ¸…ç†è­¦å‘Š:', e);
                        }
                        return null;
                    }
                } catch (e) {
                    console.error('è½®å»“è¿‘ä¼¼é”™è¯¯:', e);
                    return null;
                }
            }

            // å•åº”æ€§è®¡ç®—
            performPerspectiveTransform(srcMat, srcPoints, dstPoints) {
                try {
                    console.log('æ‰§è¡Œé€è§†å˜æ¢ - æºç‚¹:', srcPoints, 'ç›®æ ‡ç‚¹:', dstPoints);
                    
                    // ç¡®ä¿ç‚¹æ•°æ®æœ‰æ•ˆ
                    if (!srcPoints || !dstPoints) {
                        throw new Error('ç‚¹æ•°æ®æ— æ•ˆ');
                    }
                    
                    // åˆ›å»ºæºç‚¹å’Œç›®æ ‡ç‚¹æ•°ç»„
                    let srcPointArray = [];
                    let dstPointArray = [];
                    
                    // è·å–ç‚¹æ•°æ® - OpenCV.jsä¸­çš„ç‚¹æ•°æ®è®¿é—®æ–¹å¼
                    for (let i = 0; i < 4; i++) {
                        try {
                            // ç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®
                            if (srcPoints.data32F && dstPoints.data32F) {
                                let srcX = srcPoints.data32F[i * 2];
                                let srcY = srcPoints.data32F[i * 2 + 1];
                                let dstX = dstPoints.data32F[i * 2];
                                let dstY = dstPoints.data32F[i * 2 + 1];
                                
                                srcPointArray.push(srcX, srcY);
                                dstPointArray.push(dstX, dstY);
                            } else {
                                throw new Error('ç‚¹æ•°æ®æ ¼å¼é”™è¯¯');
                            }
                        } catch (pointError) {
                            console.error('ç‚¹æ•°æ®è®¿é—®é”™è¯¯:', pointError);
                            throw new Error('æ— æ³•è®¿é—®ç‚¹æ•°æ®');
                        }
                    }
                    
                    console.log('ç‚¹æ•°ç»„ - æº:', srcPointArray, 'ç›®æ ‡:', dstPointArray);
                    
                    // æ£€æŸ¥ç‚¹æ•°ç»„æ˜¯å¦æœ‰æ•ˆ
                    if (srcPointArray.length !== 8 || dstPointArray.length !== 8) {
                        throw new Error('ç‚¹æ•°ç»„é•¿åº¦é”™è¯¯');
                    }
                    
                    // åˆ›å»ºç‚¹çŸ©é˜µ - ä½¿ç”¨æ­£ç¡®çš„å‚æ•°é¡ºåº
                    let srcPointsMat = this.cv.matFromArray(4, 1, this.cv.CV_32FC2, srcPointArray);
                    let dstPointsMat = this.cv.matFromArray(4, 1, this.cv.CV_32FC2, dstPointArray);
                    
                    console.log('ç‚¹çŸ©é˜µåˆ›å»ºå®Œæˆ');
                    
                    // æ£€æŸ¥çŸ©é˜µæ˜¯å¦åˆ›å»ºæˆåŠŸ
                    if (!srcPointsMat || !dstPointsMat) {
                        throw new Error('çŸ©é˜µåˆ›å»ºå¤±è´¥');
                    }
                    
                    // è®¡ç®—å•åº”æ€§çŸ©é˜µ - ä½¿ç”¨æ­£ç¡®çš„å‚æ•°
                    console.log('å¼€å§‹è®¡ç®—å•åº”æ€§çŸ©é˜µ');
                    let homography = this.cv.findHomography(srcPointsMat, dstPointsMat, this.cv.RANSAC, 5.0);
                    
                    console.log('å•åº”æ€§çŸ©é˜µè®¡ç®—å®Œæˆ');
                    
                    // æ£€æŸ¥å•åº”æ€§çŸ©é˜µæ˜¯å¦æœ‰æ•ˆ
                    if (!homography) {
                        throw new Error('å•åº”æ€§çŸ©é˜µè®¡ç®—å¤±è´¥');
                    }
                    
                    // åº”ç”¨é€è§†å˜æ¢ - ç¡®ä¿ç›®æ ‡å°ºå¯¸æ­£ç¡®
                    let alignedImage = new this.cv.Mat();
                    let targetSize = new this.cv.Size(srcMat.cols, srcMat.rows);
                    this.cv.warpPerspective(srcMat, alignedImage, homography, targetSize, 
                                          this.cv.INTER_LINEAR, this.cv.BORDER_CONSTANT, new this.cv.Scalar(0, 0, 0, 0));
                    
                    console.log('é€è§†å˜æ¢å®Œæˆ');
                    
                    // æ¸…ç†å†…å­˜
                    try {
                        if (srcPointsMat && typeof srcPointsMat.delete === 'function') srcPointsMat.delete();
                        if (dstPointsMat && typeof dstPointsMat.delete === 'function') dstPointsMat.delete();
                        if (homography && typeof homography.delete === 'function') homography.delete();
                        if (targetSize && typeof targetSize.delete === 'function') targetSize.delete();
                    } catch (cleanupError) {
                        console.warn('å†…å­˜æ¸…ç†è­¦å‘Š:', cleanupError);
                    }
                    
                    return alignedImage;
                } catch (error) {
                    console.error('é€è§†å˜æ¢é”™è¯¯:', error);
                    throw error;
                }
            }

            // ç‚¹æ’åºå‡½æ•°ï¼šç¡®ä¿ç‚¹æŒ‰å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹é¡ºåºæ’åˆ—
            orderPoints(points) {
                if (!points) return points;

                let ordered = new this.cv.Mat();
                points.copyTo(ordered);

                // è·å–å››ä¸ªç‚¹çš„åæ ‡
                let pointsArray = [];
                for (let i = 0; i < 4; i++) {
                    pointsArray.push({
                        x: points.data32F[i * 2],
                        y: points.data32F[i * 2 + 1]
                    });
                }

                // è®¡ç®—è´¨å¿ƒ
                let centerX = pointsArray.reduce((sum, point) => sum + point.x, 0) / 4;
                let centerY = pointsArray.reduce((sum, point) => sum + point.y, 0) / 4;

                // æ ¹æ®ç›¸å¯¹äºè´¨å¿ƒçš„ä½ç½®æ’åºç‚¹
                pointsArray.sort((a, b) => {
                    if (a.y < centerY && b.y < centerY) {
                        // éƒ½åœ¨ä¸ŠåŠéƒ¨åˆ†ï¼ŒæŒ‰xæ’åº
                        return a.x - b.x;
                    } else if (a.y > centerY && b.y > centerY) {
                        // éƒ½åœ¨ä¸‹åŠéƒ¨åˆ†ï¼ŒæŒ‰xæ’åºï¼ˆé™åºï¼‰
                        return b.x - a.x;
                    } else {
                        // ä¸åœ¨åŒä¸€æ°´å¹³çº¿ä¸Šï¼ŒæŒ‰yæ’åº
                        return a.y - b.y;
                    }
                });

                // åˆ›å»ºæ–°çš„æœ‰åºç‚¹çŸ©é˜µ
                let orderedArray = [];
                pointsArray.forEach(point => {
                    orderedArray.push(point.x, point.y);
                });

                let orderedMat = this.cv.matFromArray(4, 1, this.cv.CV_32FC2, orderedArray);
                ordered.delete(); // åˆ é™¤ä¸´æ—¶å¤åˆ¶
                return orderedMat;
            }

            // ç»“æœéªŒè¯
            validateAlignment(alignedImage) {
                // å®ç°ç»“æœéªŒè¯é€»è¾‘
                // å¯ä»¥æ£€æŸ¥å¯¹é½è´¨é‡ã€å›¾åƒæ¸…æ™°åº¦ç­‰
            }

            // å·¥å…·å‡½æ•°ï¼šå°†å›¾ç‰‡è½¬æ¢ä¸ºOpenCV Mat
            imageToMat(image) {
                if (!this.cv) {
                    throw new Error('OpenCVæœªå‡†å¤‡å¥½');
                }

                const canvas = document.createElement('canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0);

                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const mat = this.cv.matFromImageData(imgData);
                return mat;
            }

            // å·¥å…·å‡½æ•°ï¼šå°†Matç»˜åˆ¶åˆ°ç”»å¸ƒ
            matToCanvas(mat, canvasId) {
                const canvas = document.getElementById(canvasId);
                this.cv.imshow(canvas, mat);
            }

            // è®¡ç®—å¯¹é½è¯¯å·®
            calculateAlignmentError(srcPoints, dstPoints, homography) {
                try {
                    // ä½¿ç”¨å•åº”æ€§çŸ©é˜µå˜æ¢æºç‚¹
                    let transformedPoints = new this.cv.Mat();
                    this.cv.perspectiveTransform(srcPoints, transformedPoints, homography);

                    // è®¡ç®—è¯¯å·®ï¼ˆå¹³å‡æ¬§å‡ é‡Œå¾—è·ç¦»ï¼‰
                    let totalError = 0;
                    let numPoints = srcPoints.rows;

                    for (let i = 0; i < numPoints; i++) {
                        let dx = transformedPoints.data32F[i * 2] - dstPoints.data32F[i * 2];
                        let dy = transformedPoints.data32F[i * 2 + 1] - dstPoints.data32F[i * 2 + 1];
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        totalError += distance;
                    }

                    transformedPoints.delete();

                    return (totalError / numPoints) / 10; // å½’ä¸€åŒ–åˆ°ç™¾åˆ†æ¯”
                } catch (error) {
                    console.error('è¯¯å·®è®¡ç®—é”™è¯¯:', error);
                    return 5.0; // é»˜è®¤è¯¯å·®
                }
            }
        }

        // åˆ›å»ºå…¨å±€å®ä¾‹
        const aligner = new AnswerSheetAligner();

        // OpenCVå‡†å¤‡å°±ç»ªå›è°ƒ
        function onOpenCVReady() {
            console.log('OpenCVå‡†å¤‡å°±ç»ªå›è°ƒè¢«è°ƒç”¨');
            console.log('cvå¯¹è±¡çŠ¶æ€:', typeof cv, cv ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
            if (typeof cv !== 'undefined') {
                console.log('cv.loadedçŠ¶æ€:', cv.loaded);
            }
            aligner.initOpenCV();
        }

        // OpenCVåŠ è½½é”™è¯¯å¤„ç†
        function onOpenCVError() {
            console.error('OpenCV.jsåŠ è½½å¤±è´¥');
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.innerHTML = 'âŒ OpenCV.jsåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
            }
        }

        // åŠ è½½ç¤ºä¾‹å›¾ç‰‡
        function loadDemoImages() {
            aligner.loadDemoImages();
        }

        // ä¸»è¦çš„å›¾åƒå¯¹é½å‡½æ•°
        async function alignImages() {
            await aligner.processImages();
        }

        // é‡ç½®æ‰€æœ‰å†…å®¹
        function resetAll() {
            aligner.resetAll();
        }

        // é¡µé¢åŠ è½½å®Œæˆåç»‘å®šäº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function () {
            console.log('DOMåŠ è½½å®Œæˆ');

            // ç»‘å®šæ–‡ä»¶ä¸Šä¼ äº‹ä»¶
            const templateFile = document.getElementById('templateFile');
            const targetFile = document.getElementById('targetFile');
            const alignBtn = document.getElementById('alignBtn');
            const demoBtn = document.getElementById('demoBtn');
            const resetBtn = document.getElementById('resetBtn');

            // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
            if (alignBtn) {
                alignBtn.disabled = true;
                console.log('åˆå§‹æŒ‰é’®çŠ¶æ€: ç¦ç”¨');
            }

            if (templateFile) {
                templateFile.addEventListener('change', function (e) {
                    console.log('æ¨¡æ¿æ–‡ä»¶ä¸Šä¼ äº‹ä»¶è§¦å‘');
                    aligner.handleImageUpload(e, 'template');
                });
            }

            if (targetFile) {
                targetFile.addEventListener('change', function (e) {
                    console.log('æ‹æ‘„æ–‡ä»¶ä¸Šä¼ äº‹ä»¶è§¦å‘');
                    aligner.handleImageUpload(e, 'target');
                });
            }

            // æ£€æŸ¥OpenCVæ˜¯å¦å·²ç»åŠ è½½
            setTimeout(() => {
                if (typeof cv !== 'undefined') {
                    console.log('å»¶è¿Ÿæ£€æŸ¥: OpenCVå·²å­˜åœ¨ï¼Œè°ƒç”¨å‡†å¤‡å°±ç»ªå›è°ƒ');
                    onOpenCVReady();
                } else {
                    console.log('å»¶è¿Ÿæ£€æŸ¥: OpenCVå°šæœªåŠ è½½');
                    // æ˜¾ç¤ºåŠ è½½æç¤º
                    const statusElement = document.getElementById('status');
                    if (statusElement) {
                        statusElement.innerHTML = 'â³ æ­£åœ¨åŠ è½½OpenCV.jsï¼Œè¯·ç¨å€™...';
                    }
                }
            }, 500);
        });

        // é¡µé¢å®Œå…¨åŠ è½½åå†æ¬¡æ£€æŸ¥
        window.addEventListener('load', function () {
            console.log('é¡µé¢å®Œå…¨åŠ è½½');
            if (typeof cv !== 'undefined') {
                console.log('é¡µé¢åŠ è½½åOpenCVå·²å­˜åœ¨');
                onOpenCVReady();
            }
        });

        // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function (event) {
            // Ctrl+R æˆ– Cmd+R é‡ç½®
            if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
                event.preventDefault();
                resetAll();
            }
            // Ctrl+A æˆ– Cmd+A å¯¹é½
            if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
                event.preventDefault();
                const alignBtn = document.getElementById('alignBtn');
                if (alignBtn && !alignBtn.disabled) {
                    alignImages();
                }
            }
        });
    </script>
</body>

</html>